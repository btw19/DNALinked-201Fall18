Virginia Capehart
vlc23
Ben Williams
btw19

Question 1: are the benchmark timings for StringStrand consistent with the 
explanation below that the time to execute cutAndSplice is O(b^2S)? 

Note that the value of b is half the number of calls to append since each cut 
(except the first) is modeled by two calls of append in the method cutAndSplice 
-- see the code. This means that b^2 will be constant in the benchmark, but S 
will vary. 

	The time is O(b^2s) because for every concatenation of a string s, a new 
	string variable must be created. There will be b concatenations, and the last
	one happens b times, making the timing O(b^2s). These times are consistent with
	this analysis because 

Question 2: are the benchmark timings for StringBuilderStrand consistent with the 
explanation below that the time to execute cutAndSplice is O(bS)? 

Note that the value of b is half the number of calls to append since each cut 
(except the first) is modeled by two calls of append in the method cutAndSplice 
-- see the code. This means that b will be constant in the benchmark, but S 
will vary. 

	The time is O(bs) because a string s is appended to the StringBuilder a total
	of s times. These times are consistent with this analysis because 

Question 3: Explain why the time for LinkStrand does not change much at all over 
all the runs in the benchmark program. Explain why you think memory is exhausted 
at the specific strand size you see in your timings -- as compared to exhaustion 
for String and StringBuilder.

	answer

